# TypeScript Classes & OOP ‚Äì Interview Guide (Detailed Reference)

This document provides **deep, interview-ready explanations (15‚Äì25+ lines per topic)** on **TypeScript classes, inheritance, abstract classes, and related OOP concepts**.  
It is designed as a **future reference** for **TypeScript, Angular, NestJS, and backend interviews**.

Each section explains **WHAT, WHY, HOW, WHEN**, plus **common interview follow-ups and pitfalls**.

---

## 1. What is a Class in TypeScript?

### What
A class in TypeScript is a **blueprint for creating objects**, combining **data (properties)** and **behavior (methods)** into a single unit.  
TypeScript classes are based on **ES6 JavaScript classes**, but add **strong typing, access modifiers, and abstraction**.

```ts
class User {
  id: number;
  name: string;

  constructor(id: number, name: string) {
    this.id = id;
    this.name = name;
  }

  getName(): string {
    return this.name;
  }
}
```

### Why classes are used
- Organize code logically
- Model real-world entities
- Improve readability and maintainability
- Enable OOP concepts (inheritance, encapsulation, polymorphism)

### When to use
- Domain modeling
- Business logic layers
- Services in frameworks like NestJS

---

## 2. Access Modifiers in TypeScript Classes

TypeScript provides **three access modifiers** to control visibility.

| Modifier | Accessible From |
|-------|----------------|
| public | Anywhere |
| protected | Class + subclasses |
| private | Same class only |

```ts
class Account {
  public id: number;
  protected balance: number;
  private pin: number;
}
```

### Why this matters
- Enforces encapsulation
- Prevents unintended access
- Improves API clarity

---

## 3. Can One Class Extend Another Class?

### Yes ‚Äî TypeScript supports inheritance using `extends`.

```ts
class Employee {
  getRole() {
    return "Employee";
  }
}

class Manager extends Employee {
  getRole() {
    return "Manager";
  }
}
```

### How inheritance works
- Child class inherits properties and methods
- Can override methods (polymorphism)
- Can call parent methods using `super`

```ts
super.getRole();
```

### When to use inheritance
- ‚Äúis-a‚Äù relationship
- Shared behavior across classes

---

## 4. What is an Abstract Class in TypeScript?

### What
An abstract class is a **base class that cannot be instantiated** and may contain **abstract methods** that must be implemented by subclasses.

```ts
abstract class Shape {
  abstract area(): number;

  describe(): string {
    return "This is a shape";
  }
}
```

### Why abstract classes exist
- Enforce implementation contracts
- Share common logic
- Prevent incomplete object creation

### When to use
- Base domain classes
- Framework core classes
- Template method pattern

---

## 5. Abstract Class vs Interface

| Feature | Abstract Class | Interface |
|------|----------------|-----------|
| Implementation | Yes | No |
| Constructors | Yes | No |
| State | Yes | No |
| Multiple inheritance | ‚ùå | ‚úÖ |

### Interview Rule
- Use **abstract class** when logic + contract are needed
- Use **interface** when only contract is needed

---

## 6. Can a Class Implement Multiple Interfaces?

### Yes ‚Äî TypeScript supports multiple interface implementation.

```ts
interface Flyable {
  fly(): void;
}

interface Swimmable {
  swim(): void;
}

class Duck implements Flyable, Swimmable {
  fly() {}
  swim() {}
}
```

### Why this is powerful
- Avoids diamond problem
- Enables flexible composition
- Preferred over multiple inheritance

---

## 7. Can We Extend Types in TypeScript?

### Types cannot be extended like classes, but can be **combined using intersections (`&`)**.

```ts
type A = { a: number };
type B = { b: string };

type C = A & B;
```

### Key difference
- `extends` ‚Üí classes & interfaces
- `&` ‚Üí type composition

### Interview Pitfall
‚ùå `type A extends B {}` ‚Üí Invalid  
‚úî Use intersection instead

---

## 8. Can We Extend Interfaces?

### Yes ‚Äî interfaces support extension.

```ts
interface User {
  id: number;
}

interface Admin extends User {
  role: string;
}
```

### Why interfaces are extensible
- Supports declaration merging
- Ideal for API contracts
- Common in framework typings

---

## 9. Can a Class Extend Multiple Classes?

### ‚ùå No ‚Äî TypeScript does NOT support multiple class inheritance.

### Why?
- Avoids diamond problem
- Simplifies object model

### Alternative
- Use interfaces
- Use composition

```ts
class Service {
  constructor(private logger: Logger) {}
}
```

---

## 10. What is Composition vs Inheritance?

### Inheritance
- Tight coupling
- ‚Äúis-a‚Äù relationship

### Composition
- Loose coupling
- ‚Äúhas-a‚Äù relationship

```ts
class Car {
  constructor(private engine: Engine) {}
}
```

### Interview Insight
üëâ Prefer **composition over inheritance** in large systems.

---

## 11. Method Overriding & Polymorphism

```ts
class Animal {
  speak() {
    return "Sound";
  }
}

class Dog extends Animal {
  speak() {
    return "Bark";
  }
}
```

### Why important
- Runtime behavior selection
- Cleaner extensibility
- Core OOP principle

---

## 12. Abstract Methods ‚Äì Follow-Up Question

### What happens if a subclass doesn‚Äôt implement abstract methods?
‚ùå Compilation error

```ts
class Circle extends Shape {} // Error
```

‚úî Enforces correctness at compile time

---

## 13. Static Members in Classes

```ts
class MathUtil {
  static PI = 3.14;
  static square(x: number) {
    return x * x;
  }
}
```

### When to use
- Utility functions
- Shared constants

---

## 14. Readonly Properties in Classes

```ts
class Config {
  readonly env: string = "prod";
}
```

### Why
- Prevent mutation
- Enforce immutability

---

## 15. Common Interview Follow-Up Questions

- Can constructors be abstract? ‚ùå
- Can interfaces have implementation? ‚ùå
- Can abstract classes have constructors? ‚úÖ
- Can a class implement a type? ‚ùå
- Can a class implement multiple interfaces? ‚úÖ
- Can we override private methods? ‚ùå

---

## Interviewer Expectations (IMPORTANT)

Interviewers want to see:
- Strong OOP fundamentals
- Correct usage of inheritance vs composition
- Awareness of TypeScript-specific rules
- Ability to explain trade-offs clearly

---

## Final Takeaway

TypeScript classes and abstraction are **core to enterprise-level applications**.  
Understanding **when to use classes, abstract classes, interfaces, and composition** is critical for **senior frontend, backend, and full-stack interviews**.
