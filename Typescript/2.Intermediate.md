
# TypeScript Intermediate Concepts ‚Äì Interview Guide (Detailed)

This guide is designed for **mid to senior-level TypeScript interviews** and real-world development.
It covers definitions, syntax, examples, diagrams (ASCII), and practical use cases.

---

## 1. Generics in TypeScript

### Definition
Generics allow you to write **reusable, type-safe code** by using placeholders for types.

### Syntax
```ts
function identity<T>(value: T): T {
  return value;
}
```

### Example
```ts
identity<number>(10);
identity("Hello"); // inferred as string
```

### Generic Constraint
```ts
function getLength<T extends { length: number }>(item: T) {
  return item.length;
}
```

### Diagram
```
Input Type -> Generic <T> -> Output Type
```

---

## 2. Union and Intersection Types

### Union (`|`)
```ts
type ID = string | number;
```

### Intersection (`&`)
```ts
type User = { name: string };
type Admin = { admin: boolean };
type AdminUser = User & Admin;
```

---

## 3. Type Narrowing

### Techniques
- typeof
- instanceof
- in
- Custom type guards

```ts
function print(value: string | number) {
  if (typeof value === "string") {
    value.toUpperCase();
  }
}
```

---

## 4. keyof Operator

```ts
type User = { id: number; name: string };
type UserKeys = keyof User;
```

---

## 5. typeof Operator

```ts
const user = { id: 1, name: "Ankit" };
type UserType = typeof user;
```

---

## What are Utility Types?
**Utility Types** are built-in generic types provided by TypeScript that help you **transform existing types**
instead of redefining them from scratch.

They help you:
- Avoid code duplication
- Keep types consistent
- Improve readability and maintainability
- Write safer and more expressive code

üìå Interview definition:
> ‚ÄúUtility types allow us to derive new types from existing ones without duplicating definitions.‚Äù

---

## Why Utility Types Are Important

- Reduce boilerplate
- Keep API contracts in sync
- Express intent clearly (partial updates, readonly views, etc.)
- Widely used in **backend APIs, React, Redux, and Node.js projects**

---

## Commonly Used Utility Types

---

## 1. Partial<T>

### Definition
Makes **all properties optional**.

### Use cases
- PATCH / update APIs
- Forms with partial input
- Draft objects

```ts
type User = {
  id: number;
  name: string;
  email: string;
};

type UpdateUser = Partial<User>;

const payload: UpdateUser = {
  name: "Alice"
};
```

üìå Interview tip:
> ‚Äú`Partial` is commonly used in update operations.‚Äù

---

## 2. Required<T>

### Definition
Makes **all properties required**, even if they were optional.

```ts
type UserDraft = {
  id?: number;
  name?: string;
};

type FinalUser = Required<UserDraft>;
```

üìå Useful when converting draft data into finalized objects.

---

## 3. Readonly<T>

### Definition
Makes all properties **immutable**.

```ts
type User = {
  id: number;
  name: string;
};

const user: Readonly<User> = {
  id: 1,
  name: "A"
};

// user.name = "B"; ‚ùå Error
```

üìå Used for:
- Configuration objects
- Preventing accidental mutation

---

## 4. Pick<T, K>

### Definition
Creates a new type by **selecting specific keys**.

```ts
type User = {
  id: number;
  name: string;
  email: string;
};

type UserPreview = Pick<User, "id" | "name">;
```

üìå Commonly used for DTOs and API responses.

---

## 5. Omit<T, K>

### Definition
Creates a new type by **removing specific keys**.

```ts
type UserWithoutEmail = Omit<User, "email">;
```

üìå Very common in backend responses.

---

## 6. Record<K, T>

### Definition
Creates an object type with **keys K and values T**.

```ts
type Roles = "admin" | "user";

type RolePermissions = Record<Roles, string[]>;

const permissions: RolePermissions = {
  admin: ["read", "write"],
  user: ["read"]
};
```

üìå Used for maps, dictionaries, and lookup tables.

---

## 7. Exclude<T, U>

### Definition
Removes specific types from a union.

```ts
type Status = "success" | "error" | "loading";

type FinalStatus = Exclude<Status, "loading">;
```

---

## 8. Extract<T, U>

### Definition
Extracts only the **common types** between unions.

```ts
type Status = "success" | "error" | "loading";

type ActiveStatus = Extract<Status, "success" | "error">;
```

üìå Difference:
- `Exclude` removes
- `Extract` keeps

---

## 9. NonNullable<T>

### Definition
Removes `null` and `undefined` from a type.

```ts
type Value = string | null | undefined;

type SafeValue = NonNullable<Value>;
```

---

## 10. ReturnType<T>

### Definition
Extracts the **return type of a function**.

```ts
function getUser() {
  return { id: 1, name: "A" };
}

type User = ReturnType<typeof getUser>;
```

üìå Very common in Redux and API typing.

---

## 11. Parameters<T>

### Definition
Extracts the **parameter types** of a function.

```ts
function login(username: string, password: string) {}

type LoginParams = Parameters<typeof login>;
// [string, string]
```

---

## Utility Types ‚Äì Quick Comparison

| Utility Type | Purpose |
|------------|--------|
| Partial | Make properties optional |
| Required | Make properties required |
| Readonly | Prevent mutation |
| Pick | Select properties |
| Omit | Remove properties |
| Record | Key‚Äìvalue mapping |
| Exclude | Remove from union |
| Extract | Keep from union |
| NonNullable | Remove null/undefined |
| ReturnType | Extract function return |
| Parameters | Extract function parameters |

---

## Real-World Backend Example

```ts
interface ApiResponse<T> {
  data: T;
  error?: string;
}

type User = {
  id: number;
  name: string;
  email: string;
};

type UserListResponse = ApiResponse<Pick<User, "id" | "name">>;
```

---

### Definition
Makes all properties immutable.

```ts
type ReadonlyUser = Readonly<User>;
```

### Example
```ts
const user: ReadonlyUser = { id: 1, name: "A" };
// user.name = "B"; ‚ùå Error
```

---

## Interview Tips

- Prefer Generics over any
- Use Record for object maps
- Use Readonly for immutability
- Master utility types

---

## Conclusion

These concepts are essential for writing **scalable, maintainable, and type-safe TypeScript applications**.

---
