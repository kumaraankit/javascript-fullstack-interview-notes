
# TypeScript Intermediate Concepts – Interview Guide (Detailed)

This guide is designed for **mid to senior-level TypeScript interviews** and real-world development.
It covers definitions, syntax, examples, diagrams (ASCII), and practical use cases.

---

## 1. Generics in TypeScript

### Definition
Generics allow you to write **reusable, type-safe code** by using placeholders for types.

### Syntax
```ts
function identity<T>(value: T): T {
  return value;
}
```

### Example
```ts
identity<number>(10);
identity("Hello"); // inferred as string
```

### Generic Constraint
```ts
function getLength<T extends { length: number }>(item: T) {
  return item.length;
}
```

### Diagram
```
Input Type -> Generic <T> -> Output Type
```

---

## 2. Union and Intersection Types

### Union (`|`)
```ts
type ID = string | number;
```

### Intersection (`&`)
```ts
type User = { name: string };
type Admin = { admin: boolean };
type AdminUser = User & Admin;
```

---

## 3. Type Narrowing

### Techniques
- typeof
- instanceof
- in
- Custom type guards

```ts
function print(value: string | number) {
  if (typeof value === "string") {
    value.toUpperCase();
  }
}
```

---

## 4. keyof Operator

```ts
type User = { id: number; name: string };
type UserKeys = keyof User;
```

---

## 5. typeof Operator

```ts
const user = { id: 1, name: "Ankit" };
type UserType = typeof user;
```

---

## 6. Utility Types

### Partial<T>
```ts
type PartialUser = Partial<User>;
```

### Required<T>
```ts
type CompleteUser = Required<PartialUser>;
```

### Pick<T, K>
```ts
type UserPreview = Pick<User, "id" | "name">;
```

### Omit<T, K>
```ts
type UserWithoutId = Omit<User, "id">;
```

---

## 7. Record<K, T>

### Definition
Creates an object type with **specific keys and value types**.

### Syntax
```ts
Record<Keys, Type>
```

### Example
```ts
type Role = "admin" | "user";
type Permissions = Record<Role, string[]>;

const perms: Permissions = {
  admin: ["read", "write"],
  user: ["read"]
};
```

---

## 8. Exclude<T, U>

### Definition
Removes types from T that are assignable to U.

```ts
type Status = "success" | "error" | "loading";
type ActiveStatus = Exclude<Status, "loading">;
```

---

## 9. Extract<T, U>

### Definition
Extracts types from T that are assignable to U.

```ts
type Result = Extract<Status, "success" | "error">;
```

---

## 10. Readonly<T>

### Definition
Makes all properties immutable.

```ts
type ReadonlyUser = Readonly<User>;
```

### Example
```ts
const user: ReadonlyUser = { id: 1, name: "A" };
// user.name = "B"; ❌ Error
```

---

## Interview Tips

- Prefer Generics over any
- Use Record for object maps
- Use Readonly for immutability
- Master utility types

---

## Conclusion

These concepts are essential for writing **scalable, maintainable, and type-safe TypeScript applications**.

---
